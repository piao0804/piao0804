# 一，为什么写单元测试？

 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。

 比如对函数abs()，我们可以编写出以下几个测试用例：

输入正数，比如1、1.2、0.99，期待返回值与输入相同；

输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；

输入0，期待返回0；

输入非数值类型，比如None、[]、{}，期待抛出TypeError。

把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。

如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。

单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。


冒泡排序是一种简单基础的排序算法，相信在大学课堂里老师已经讲过了，现在我基于Java来实现一遍。

二，简述

冒泡排序正如其关键词一样，杂乱的气泡经过浮动，最后大的气泡飘到了上面而小的气泡在下面，无序的元素序列的排序规则也是如此，每次比较相邻的两个数值，如果前面的数值大于后面的数值则进行交换，最后会将本次遍历出来的最大数值排到最后位，然后按如此规则对剩余的无序序列进行类似的冒泡处理。

算法描述

1比较相邻的两个元素，如果前面的比后面的大，则交换两个元素；

2对每每相邻的元素都进行这样的比较操作，从开始的一对到最后一对，这样最后的元素会是本次遍历完剩下的最大的元素；

3针对所有的元素执行以上步骤，除了已经指派出来的最大的元素（或序列，序列排在了最末尾）

4重复以上步骤直至排序完成。

代码：

    /**
       * 冒泡排序
       
      * 循环比较相邻的两个数，将较大的数放在后面
      
      *  nums 待排序数值序列
      
       */
       
      private static int[] bubbleSort(int[] nums) {
      
          int len = nums.length;
          
          if(len == 0 || len == 1) {
          
             return nums;
         }
         for(int i = 0; i < len; i++) {
         
             for(int j = 0, subLen = len - 1 - i; j < subLen; j++) {
             
                 if(nums[j + 1] < nums[j]) {
                 
                     int tmp = nums[j + 1];
                     
                     nums[j + 1] = nums[j];
                     
                     nums[j] = tmp;
                     
                 }
                 
             }
             
         }
         
         return nums;
         
     }




















